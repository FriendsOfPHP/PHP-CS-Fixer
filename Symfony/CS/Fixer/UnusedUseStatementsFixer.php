<?php

/*
 * This file is part of the PHP CS utility.
 *
 * (c) Fabien Potencier <fabien@symfony.com>
 *
 * This source file is subject to the MIT license that is bundled
 * with this source code in the file LICENSE.
 */

namespace Symfony\CS\Fixer;

use Symfony\CS\FixerInterface;

/**
 * @author Fabien Potencier <fabien@symfony.com>
 */
class UnusedUseStatementsFixer implements FixerInterface
{
    public function fix(\SplFileInfo $file, $content)
    {
        // some fixtures are auto-generated by Symfony and may contain unused use statements
        if (false !== strpos($file, '/Fixtures/')) {
            return $content;
        }

        $token = token_get_all($content);
        $usesToDelete = array();
        $lastElement = null;
        $currentUse = array();
        foreach ($token as $key => $val) {
            if (! empty($currentUse)) {
                $currentUse[] = $key;

                if ($val === ';') {
                    // We have to delete also the space before the use
                    reset($currentUse);
                    $firstKey = current($currentUse) - 1;
                    if (isset($token[$firstKey]) and static::isTokenType($token[$firstKey], T_WHITESPACE)) {
                        $currentUse[] = $firstKey;
                    }

                    $usesToDelete[$lastElement] = $currentUse;
                    $currentUse = array();
                }
            }

            if (static::isTokenType($val, T_USE)) {
                $currentUse[] = $key;
            }

            if (static::isTokenType($val, T_STRING)) {
                // strtoupper because class invocation as case-insensitive
                $lastElement = strtoupper($val[1]);

                if (isset($usesToDelete[$lastElement])) {
                    unset($usesToDelete[$lastElement]);
                }
            }
        }

        foreach ($usesToDelete as $linesToDrop) {
            foreach ($linesToDrop as $key) {
                unset($token[$key]);
            }
        }

        $content = '';
        foreach ($token as $val) {
            $content .= is_array($val) ? $val[1] : $val;
        }

        return $content;
    }

    public function getLevel()
    {
        return FixerInterface::ALL_LEVEL;
    }

    public function getPriority()
    {
        // should be run before the ExtraEmptyLinesFixer
        return 5;
    }

    public function supports(\SplFileInfo $file)
    {
        return 'php' == pathinfo($file->getFilename(), PATHINFO_EXTENSION);
    }

    public function getName()
    {
        return 'unused_use';
    }

    public function getDescription()
    {
        return 'Unused use statements must be removed.';
    }

    private static function isTokenType($token, $type)
    {
        return (is_array($token) and isset($token[0]) and $token[0] === $type);
    }
}
